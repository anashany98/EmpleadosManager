import { toast } from 'sonner';

export const BASE_URL = import.meta.env.VITE_API_URL || '';
// Avoid double /api if VITE_API_URL already ends with it
export const API_URL = BASE_URL.endsWith('/api') || BASE_URL.endsWith('/api/')
    ? BASE_URL.replace(/\/$/, '')
    : `${BASE_URL.replace(/\/$/, '')}/api`;
// console.log('API_URL:', API_URL);

const getCookie = (name: string) => {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop()!.split(';').shift() || '';
    return '';
};

const getHeaders = (isFormData = false, method: string = 'GET') => {
    const headers: any = {};
    if (!isFormData) headers['Content-Type'] = 'application/json';

    const upper = method.toUpperCase();
    if (upper !== 'GET' && upper !== 'HEAD' && upper !== 'OPTIONS') {
        const csrfToken = getCookie('csrf_token');
        if (csrfToken) headers['X-CSRF-Token'] = csrfToken;
    }
    return headers;
};

// Queue to hold requests while refreshing
let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
    failedQueue.forEach(prom => {
        if (error) {
            prom.reject(error);
        } else {
            prom.resolve(token);
        }
    });
    failedQueue = [];
};

const customFetch = async (endpoint: string, options: any = {}): Promise<any> => {
    const url = `${API_URL}${endpoint}`;

    // Config fetch
    const method = options.method || 'GET';
    const config: RequestInit = {
        method,
        headers: getHeaders(options.body instanceof FormData, method),
        body: options.body instanceof FormData ? options.body : (options.body ? JSON.stringify(options.body) : undefined),
        credentials: 'include'
    };

    try {
        const res = await fetch(url, config);

        // Handle 401 (Unauthorized) - Only if not logging in or refreshing
        if (res.status === 401 && !endpoint.includes('/auth/login') && !endpoint.includes('/auth/refresh') && !endpoint.includes('/auth/me')) {
            if (isRefreshing) {
                // If already refreshing, queue this request
                return new Promise((resolve, reject) => {
                    failedQueue.push({ resolve, reject });
                }).then(() => {
                    return customFetch(endpoint, options);
                }).catch((err) => {
                    throw err;
                });
            }

            isRefreshing = true;
            try {
                // Attempt refresh
                const refreshRes = await fetch(`${API_URL}/auth/refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });

                if (!refreshRes.ok) {
                    throw new Error('Refresh failed');
                }

                await refreshRes.json();

                // data.data contains { token, refreshToken } (if generated by AuthController)
                // Need to verify response structure from AuthController.refresh
                // It returns ApiResponse.success(res, { token, refreshToken })
                // const newTokens = data.data;

                isRefreshing = false;
                processQueue(null, null);

                // Retry original request
                return customFetch(endpoint, options);

            } catch (refreshErr) {
                isRefreshing = false;
                processQueue(refreshErr, null);

                // Complete logout (avoid reload loop if already on auth pages)
                const path = window.location.pathname;
                const isAuthPage = path.startsWith('/login') || path.startsWith('/request-reset') || path.startsWith('/reset-password');
                if (!isAuthPage) {
                    window.location.href = '/login';
                }
                throw refreshErr;
            }
        }

        if (!res.ok) {
            // Generic error handling
            // Try to parse JSON message, fallback to text
            let errMsg = res.statusText;
            try {
                const text = await res.text();
                // Check if text is JSON
                try {
                    const json = JSON.parse(text);
                    if (json.message) errMsg = json.message;
                    else errMsg = text;
                } catch {
                    errMsg = text;
                }
                // If the error message is a JSON string itself (double encoded), try to parse it?
                // Current logic just throws the text
                throw new Error(text); // Keep existing behavior of throwing text for parsing in UI
            } catch (e: any) {
                // Determine error message
                let finalMsg = e.message || errMsg;
                try {
                    const json = JSON.parse(finalMsg);
                    if (json.message) finalMsg = json.message;
                } catch { }

                if (res.status === 403) {
                    toast.error('⛔ Acceso denegado: No tienes permiso para esta acción.');
                }

                throw new Error(finalMsg);
            }
        }

        if (options.responseType === 'blob') return res.blob();
        return res.json();

    } catch (error) {
        throw error;
    }
};

export const api = {
    get: (endpoint: string, options: any = {}) => customFetch(endpoint, { ...options, method: 'GET' }),
    post: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'POST', body }),
    put: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'PUT', body }),
    patch: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'PATCH', body }),
    delete: (endpoint: string) => customFetch(endpoint, { method: 'DELETE' })
};
