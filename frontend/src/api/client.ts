export const BASE_URL = 'http://192.168.1.38:3000';
export const API_URL = `${BASE_URL}/api`;
console.log('API_URL being used (Hardcoded):', API_URL);

const getHeaders = (isFormData = false) => {
    const headers: any = {};
    if (!isFormData) headers['Content-Type'] = 'application/json';

    const token = localStorage.getItem('token');
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    return headers;
};

// Queue to hold requests while refreshing
let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
    failedQueue.forEach(prom => {
        if (error) {
            prom.reject(error);
        } else {
            prom.resolve(token);
        }
    });
    failedQueue = [];
};

const customFetch = async (endpoint: string, options: any = {}): Promise<any> => {
    const url = `${API_URL}${endpoint}`;

    // Config fetch
    const config: RequestInit = {
        method: options.method || 'GET',
        headers: getHeaders(options.body instanceof FormData),
        body: options.body instanceof FormData ? options.body : (options.body ? JSON.stringify(options.body) : undefined)
    };

    try {
        const res = await fetch(url, config);

        // Handle 401 (Unauthorized) - Only if not logging in or refreshing
        if (res.status === 401 && !endpoint.includes('/auth/login') && !endpoint.includes('/auth/refresh')) {
            if (isRefreshing) {
                // If already refreshing, queue this request
                return new Promise((resolve, reject) => {
                    failedQueue.push({ resolve, reject });
                }).then(() => {
                    return customFetch(endpoint, options);
                }).catch((err) => {
                    throw err;
                });
            }

            isRefreshing = true;
            const refreshToken = localStorage.getItem('refreshToken');

            if (!refreshToken) {
                // No refresh token, force logout
                localStorage.removeItem('token');
                window.location.href = '/login';
                throw new Error('SesiÃ³n expirada');
            }

            try {
                // Attempt refresh
                const refreshRes = await fetch(`${API_URL}/auth/refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ refreshToken })
                });

                if (!refreshRes.ok) {
                    throw new Error('Refresh failed');
                }

                const data = await refreshRes.json();

                // data.data contains { token, refreshToken } (if generated by AuthController)
                // Need to verify response structure from AuthController.refresh
                // It returns ApiResponse.success(res, { token, refreshToken })
                const newTokens = data.data;

                localStorage.setItem('token', newTokens.token);
                if (newTokens.refreshToken) {
                    localStorage.setItem('refreshToken', newTokens.refreshToken);
                }

                isRefreshing = false;
                processQueue(null, newTokens.token);

                // Retry original request
                return customFetch(endpoint, options);

            } catch (refreshErr) {
                isRefreshing = false;
                processQueue(refreshErr, null);

                // Complete logout
                localStorage.removeItem('token');
                localStorage.removeItem('refreshToken');
                window.location.href = '/login';
                throw refreshErr;
            }
        }

        if (!res.ok) {
            // Generic error handling
            // Try to parse JSON message, fallback to text
            let errMsg = res.statusText;
            try {
                const text = await res.text();
                // Check if text is JSON
                try {
                    const json = JSON.parse(text);
                    if (json.message) errMsg = json.message;
                    else errMsg = text;
                } catch {
                    errMsg = text;
                }
                // If the error message is a JSON string itself (double encoded), try to parse it?
                // Current logic just throws the text
                throw new Error(text); // Keep existing behavior of throwing text for parsing in UI
            } catch (e: any) {
                throw new Error(e.message || errMsg);
            }
        }

        if (options.responseType === 'blob') return res.blob();
        return res.json();

    } catch (error) {
        throw error;
    }
};

export const api = {
    get: (endpoint: string, options: any = {}) => customFetch(endpoint, { ...options, method: 'GET' }),
    post: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'POST', body }),
    put: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'PUT', body }),
    patch: (endpoint: string, body: any, options: any = {}) => customFetch(endpoint, { ...options, method: 'PATCH', body }),
    delete: (endpoint: string) => customFetch(endpoint, { method: 'DELETE' })
};
